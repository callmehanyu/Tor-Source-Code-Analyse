
<!DOCTYPE html>
<html>
<head>
<title>Tor源码分析之circuit多路复用</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<p>Tor版本：0.4.2.5</p>
<hr>
<p>PS:stream=stream conn=stream connection=ap connection=entry connection</p>
<hr>
<p>在Tor协议中，电路（circuit）建立的代价是比较高的，所以一条电路允许被多个流（stream）复用。我们来看下流是如何选择一条合适的电路的。</p>
<h1 id="1-">1 数据结构</h1>
<p>我们这里主要关注与流、电路相关的数据结构。</p>
<h2 id="1-1-connection-">1.1 connection相关</h2>
<h3 id="1-1-1-src-core-mainloop-connection-c">1.1.1 /src/core/mainloop/connection.c</h3>
<p>The module implements the abstract type,<code>connection_t</code>在<code>connection_st.h</code>中定义（见<strong>1.1.2</strong>节），The subtypes are:</p>
<ul>
<li><code>listener_connection_t</code>, implemented here in connection.c</li><li><code>dir_connection_t</code>, implemented in directory.c</li><li><code>or_connection_t</code>, implemented in connection_or.c</li><li><code>edge_connection_t</code>, 在<code>edge_connection_st.h</code>中定义（见<strong>1.1.3</strong>节），implemented in connection_edge.h, along with its subtype(s):<ul>
<li><code>entry_connection_t</code>, 在<code>entry_connection_st.h</code>中定义（见<strong>1.1.4</strong>节），also implemented in connection_edge.c</li></ul>
</li><li><code>control_connection_t</code>, implemented in control.c</li></ul>
<h3 id="1-1-2-src-core-or-connection_st-h">1.1.2 /src/core/or/connection_st.h</h3>
<p>connection分为OR connection，exit connection和<strong>AP connection</strong>三种类型，每一个connection都有时刻变化的状态和输入输出缓冲区。我们主要关注部分如下属性：</p>
<pre><code>uint8_t state; /**&lt; Current state of this connection. */
unsigned int type:5; /**&lt; What kind of connection is this? */
unsigned int purpose:5; /**&lt; Only used for DIR and EXIT types currently. */
？unsigned int linked:1; /**&lt; True if there is, or has been, a linked_conn. */
？unsigned int proxy_state:4;/** CONNECT/SOCKS proxy client handshake state (for outgoing connections). */
uint64_t global_identifier;/** Unique identifier for this connection on this Tor instance. */
？int socket_family; /**&lt; Address family of this connection&#39;s socket.  Usually AF_INET, but it can also be AF_UNIX, or AF_INET6 */
？tor_addr_t addr; /**&lt; IP that socket &quot;s&quot; is directly connected to; may be the IP address for a proxy or pluggable transport,see &quot;address&quot; for the address of the final destination.*/
？uint16_t port; /**&lt; If non-zero, port that socket &quot;s&quot; is directly connected to;may be the port for a proxy or pluggable transport,see &quot;address&quot; for the port at the final destination. */
？char *address; /**&lt; FQDN (or IP) and port of the final destination for this connection; this is always the remote address, it is passed to a proxy or pluggable transport if one in use.See &quot;addr&quot; and &quot;port&quot; for the address that socket &quot;s&quot; is directly connected to.strdup into this, because free_connection() frees it. */
</code></pre><h3 id="1-1-3-src-core-or-edge_connection_st-h">1.1.3 /src/core/or/edge_connection_st.h</h3>
<p>edge connection 分为entry (ap，stream) connection 和 exit connection.</p>
<pre><code>connection_t base_;
struct edge_connection_t *next_stream; /**&lt; Points to the next stream at this edge, if any */
int package_window; /**&lt; How many more relay cells can I send into the circuit? */
int deliver_window; /**&lt; How many more relay cells can end at me? */
struct circuit_t *on_circuit; /**&lt; The circuit (if any) that this edge connection is using. */
?struct crypt_path_t *cpath_layer;/** A pointer to which node in the circ this conn exits at.  Set for AP connections and for hidden service exit connections. */
rend_data_t *rend_data;  /** What rendezvous service are we querying for (if an AP) or providing (if an exit)? */
struct hs_ident_edge_conn_t *hs_ident;/* Hidden service connection identifier for edge connections. Used by the HS client-side code to identify client SOCKS connections and by the service-side code to match HS circuits with their streams. */
streamid_t stream_id; /**&lt; The stream ID used for this edge connection on its circuit */
uint16_t end_reason;/** The reason why this connection is closing; passed to the controller. */
unsigned int is_dns_request:1;/** True iff this connection is for a DNS request only. */
unsigned int is_reverse_dns_lookup:1;/** True iff this connection is for a PTR DNS request. (exit only) */
uint64_t dirreq_id;/** Unique ID for directory requests; this used to be in connection_t, but that&#39;s going away and being used on channels instead.  We still tag edge connections with dirreq_id from circuits, so it&#39;s copied here. */
</code></pre><h3 id="1-1-4-src-core-or-entry_connection_st-h">1.1.4 /src/core/or/entry_connection_st.h</h3>
<p>entry connection 分为 SOCKS connection、 DNS request、 TransPort connection 、 NATD connection</p>
<pre><code>struct edge_connection_t edge_;

  /** Nickname of planned exit node -- used with .exit support. */
  /* XXX prop220: we need to make chosen_exit_name able to encode Ed IDs too.
   * That&#39;s logically part of the UI parts for prop220 though. */
char *chosen_exit_name;

socks_request_t *socks_request; /**&lt; SOCKS structure describing request (AP
                                   * only.) */

  /* === Isolation related, AP only. === */
entry_port_cfg_t entry_cfg;
  /** AP only: The newnym epoch in which we created this connection. */
unsigned nym_epoch;

  /** AP only: The original requested address before we rewrote it. */
char *original_dest_address;
  /* Other fields to isolate on already exist.  The ClientAddr is addr.  The
     ClientProtocol is a combination of type and socks_request-&gt;
     socks_version.  SocksAuth is socks_request-&gt;username/password.
     DestAddr is in socks_request-&gt;address. */

  /** Number of times we&#39;ve reassigned this application connection to
   * a new circuit. We keep track because the timeout is longer if we&#39;ve
   * already retried several times. */
uint8_t num_socks_retries;

#define NUM_CIRCUITS_LAUNCHED_THRESHOLD 10
  /** Number of times we&#39;ve launched a circuit to handle this stream. If
    * it gets too high, that could indicate an inconsistency between our
    * &quot;launch a circuit to handle this stream&quot; logic and our &quot;attach our
    * stream to one of the available circuits&quot; logic. */
unsigned int num_circuits_launched:4;

  /** True iff this stream must attach to a one-hop circuit (e.g. for
   * begin_dir). */
unsigned int want_onehop:1;
  /** True iff this stream should use a BEGIN_DIR relay command to establish
   * itself rather than BEGIN (either via onehop or via a whole circuit). */
unsigned int use_begindir:1;

  /** For AP connections only. If 1, and we fail to reach the chosen exit,
   * stop requiring it. */
unsigned int chosen_exit_optional:1;
  /** For AP connections only. If non-zero, this exit node was picked as
   * a result of the TrackHostExit, and the value decrements every time
   * we fail to complete a circuit to our chosen exit -- if it reaches
   * zero, abandon the associated mapaddress. */
unsigned int chosen_exit_retries:3;

  /** True iff this is an AP connection that came from a transparent or
   * NATd connection */
unsigned int is_transparent_ap:1;

  /** For AP connections only: Set if this connection&#39;s target exit node
   * allows optimistic data (that is, data sent on this stream before
   * the exit has sent a CONNECTED cell) and we have chosen to use it.
   */
unsigned int may_use_optimistic_data : 1;
</code></pre><h2 id="1-2-circuit-">1.2 circuit 相关</h2>
<h3 id="1-2-1src-core-or-circuit_st-h">1.2.1src\core\or\circuit_st.h</h3>
<p>circuit是洋葱路由网络上的路径。Applications可以连接到circuit的一端，并可以在circuit的另一端创建exit connections。 AP和exit connections只有一个与之关联的circuit（因此，当circuit关闭时，这些连接类型也会关闭），而OR connections可一次多路复用多个circuit，即使没有circuit在OR connections上面运行，它们也不会关闭。circuit_t 有两个子类：<code>origin_circuit_t</code>和<code>or_circuit_t</code></p>
<pre><code>  /** The channel that is next in this circuit. */
channel_t *n_chan;

  /**
   * The circuit_id used in the next (forward) hop of this circuit;
   * this is unique to n_chan, but this ordered pair is globally
   * unique:
   *
   * (n_chan-&gt;global_identifier, n_circ_id)
   */
 circid_t n_circ_id;
  /** Queue of cells waiting to be transmitted on n_chan */
  cell_queue_t n_chan_cells;

  /**
   * The hop to which we want to extend this circuit.  Should be NULL if
   * the circuit has attached to a channel.
   */
  extend_info_t *n_hop;

  /** True iff we are waiting for n_chan_cells to become less full before
   * allowing p_streams to add any more cells. (Origin circuit only.) */
  unsigned int streams_blocked_on_n_chan : 1;
  /** True iff we are waiting for p_chan_cells to become less full before
   * allowing n_streams to add any more cells. (OR circuit only.) */
  unsigned int streams_blocked_on_p_chan : 1;
  /** True iff this circuit has received a DESTROY cell in either direction */
  unsigned int received_destroy : 1;

  /** True iff we have sent a sufficiently random data cell since last
   * we reset send_randomness_after_n_cells. */
  unsigned int have_sent_sufficiently_random_cell : 1;

  uint8_t state; /**&lt; Current status of this circuit. */
  uint8_t purpose; /**&lt; Why are we creating this circuit? */
/** How many relay data cells can we package (read from edge streams)
   * on this circuit before we receive a circuit-level sendme cell asking
   * for more? */
  int package_window;
  /** How many relay data cells will we deliver (write to edge streams)
   * on this circuit? When deliver_window gets low, we send some
   * circuit-level sendme cells to indicate that we&#39;re willing to accept
   * more. */
  int deliver_window;
  /**
   * How many cells do we have until we need to send one that contains
   * sufficient randomness?  Used to ensure that authenticated SENDME cells
   * will reflect some unpredictable information.
   **/
  uint16_t send_randomness_after_n_cells;
  /** Temporary field used during circuits_handle_oom. */
  uint32_t age_tmp;

  /** For storage while n_chan is pending (state CIRCUIT_STATE_CHAN_WAIT). */
  struct create_cell_t *n_chan_create_cell;

  /** When did circuit construction actually begin (ie send the
   * CREATE cell or begin cannibalization).
   *
   * Note: This timer will get reset if we decide to cannibalize
   * a circuit. It may also get reset during certain phases of hidden
   * service circuit use.
   *
   * We keep this timestamp with a higher resolution than most so that the
   * circuit-build-time tracking code can get millisecond resolution.
   */
  struct timeval timestamp_began;

  /** This timestamp marks when the init_circuit_base constructor ran. */
  struct timeval timestamp_created;

  /** When the circuit was first used, or 0 if the circuit is clean.
   *
   * XXXX Note that some code will artificially adjust this value backward
   * in time in order to indicate that a circuit shouldn&#39;t be used for new
   * streams, but that it can stay alive as long as it has streams on it.
   * That&#39;s a kludge we should fix.
   *
   * XXX The CBT code uses this field to record when HS-related
   * circuits entered certain states.  This usage probably won&#39;t
   * interfere with this field&#39;s primary purpose, but we should
   * document it more thoroughly to make sure of that.
   *
   * XXX The SocksPort option KeepaliveIsolateSOCKSAuth will artificially
   * adjust this value forward each time a suitable stream is attached to an
   * already constructed circuit, potentially keeping the circuit alive
   * indefinitely.
   */
  time_t timestamp_dirty;

  uint16_t marked_for_close; /**&lt; Should we close this circuit at the end of
                              * the main loop? (If true, holds the line number
                              * where this circuit was marked.) */
  const char *marked_for_close_file; /**&lt; For debugging: in which file was this
                                      * circuit marked for close? */
  /** For what reason (See END_CIRC_REASON...) is this circuit being closed?
   * This field is set in circuit_mark_for_close and used later in
   * circuit_about_to_free. */
  int marked_for_close_reason;
  /** As marked_for_close_reason, but reflects the underlying reason for
   * closing this circuit.
   */
  int marked_for_close_orig_reason;

  /** Unique ID for measuring tunneled network status requests. */
  uint64_t dirreq_id;
  /** If set, points to an HS token that this circuit might be carrying.
   *  Used by the HS circuitmap.  */
  struct hs_token_t *hs_token;
  /** Hashtable node: used to look up the circuit by its HS token using the HS
      circuitmap. */
  HT_ENTRY(circuit_t) hs_circuitmap_node;

  /** Adaptive Padding state machines: these are immutable. The state machines
   *  that come from the consensus are saved to a global structure, to avoid
   *  per-circuit allocations. This merely points to the global copy in
   *  origin_padding_machines or relay_padding_machines that should never
   *  change or get deallocated.
   *
   *  Each element of this array corresponds to a different padding machine,
   *  and we can have up to CIRCPAD_MAX_MACHINES such machines. */
  const struct circpad_machine_spec_t *padding_machine[CIRCPAD_MAX_MACHINES];
</code></pre><h3 id="1-2-2-src-core-or-origin_circuit_st-h">1.2.2 \src\core\or\origin_circuit_st.h</h3>
<p>用于circuit的build（/src/core/or/circuitbuild.c）与use（/src/core/or/circuituse.c）。保留cipher keys和状态，以便沿着给定的circuit发送数据。在OP处，它具有一系列密码，每个密码与circuit上的单个OR共享。单独的密码用于“向前”（远离OP）和“向后”（朝OP）数据。在OR处，circuit只有两个stream cipher：一个用于数据前进，而另一个用于数据后退。</p>
<pre><code>circuit_t base_;

  /** Linked list of AP streams (or EXIT streams if hidden service)
   * associated with this circuit. */
edge_connection_t *p_streams;

  /** Smartlist of half-closed streams (half_edge_t*) that still
   * have pending activity */
smartlist_t *half_streams;

  /** Build state for this circuit. It includes the intended path
   * length, the chosen exit router, rendezvous information, etc.
   */
  cpath_build_state_t *build_state;
  /** The doubly-linked list of crypt_path_t entries, one per hop,
   * for this circuit. This includes ciphers for each hop,
   * integrity-checking digests for each hop, and package/delivery
   * windows for each hop.
   */
  crypt_path_t *cpath;

  /** Holds all rendezvous data on either client or service side. */
  rend_data_t *rend_data;

  /** Holds hidden service identifier on either client or service side. This
   * is for both introduction and rendezvous circuit. */
  struct hs_ident_circuit_t *hs_ident;

  /** Holds the data that the entry guard system uses to track the
   * status of the guard this circuit is using, and thereby to determine
   * whether this circuit can be used. */
  struct circuit_guard_state_t *guard_state;

  /** How many more relay_early cells can we send on this circuit, according
   * to the specification? */
  unsigned int remaining_relay_early_cells : 4;

  /** Set if this circuit is insanely old and we already informed the user */
  unsigned int is_ancient : 1;

  /** Set if this circuit has already been opened. Used to detect
   * cannibalized circuits. */
  unsigned int has_opened : 1;

  /**
   * Path bias state machine. Used to ensure integrity of our
   * circuit building and usage accounting. See path_state_t
   * for more details.
   */
  path_state_bitfield_t path_state : 3;

  /* If this flag is set, we should not consider attaching any more
   * connections to this circuit. */
  unsigned int unusable_for_new_conns : 1;

  /* If this flag is set (due to padding negotiation failure), we should
   * not try to negotiate further circuit padding. */
  unsigned padding_negotiation_failed : 1;

  /**
   * Tristate variable to guard against pathbias miscounting
   * due to circuit purpose transitions changing the decision
   * of pathbias_should_count(). This variable is informational
   * only. The current results of pathbias_should_count() are
   * the official decision for pathbias accounting.
   */
  uint8_t pathbias_shouldcount;
#define PATHBIAS_SHOULDCOUNT_UNDECIDED 0
#define PATHBIAS_SHOULDCOUNT_IGNORED   1
#define PATHBIAS_SHOULDCOUNT_COUNTED   2

  /** For path probing. Store the temporary probe stream ID
   * for response comparison */
  streamid_t pathbias_probe_id;

  /** For path probing. Store the temporary probe address nonce
   * (in host byte order) for response comparison. */
  uint32_t pathbias_probe_nonce;

  /** Set iff this is a hidden-service circuit which has timed out
   * according to our current circuit-build timeout, but which has
   * been kept around because it might still succeed in connecting to
   * its destination, and which is not a fully-connected rendezvous
   * circuit.
   *
   * (We clear this flag for client-side rendezvous circuits when they
   * are &#39;joined&#39; to the other side&#39;s rendezvous circuit, so that
   * connection_ap_handshake_attach_circuit can put client streams on
   * the circuit.  We also clear this flag for service-side rendezvous
   * circuits when they are &#39;joined&#39; to a client&#39;s rend circ, but only
   * for symmetry with the client case.  Client-side introduction
   * circuits are closed when we get a joined rend circ, and
   * service-side introduction circuits never have this flag set.) */
  unsigned int hs_circ_has_timed_out : 1;

  /** Set iff this circuit has been given a relaxed timeout because
   * no circuits have opened. Used to prevent spamming logs. */
  unsigned int relaxed_timeout : 1;

  /** Set iff this is a service-side rendezvous circuit for which a
   * new connection attempt has been launched.  We consider launching
   * a new service-side rend circ to a client when the previous one
   * fails; now that we don&#39;t necessarily close a service-side rend
   * circ when we launch a new one to the same client, this flag keeps
   * us from launching two retries for the same failed rend circ. */
  unsigned int hs_service_side_rend_circ_has_been_relaunched : 1;

  /** What commands were sent over this circuit that decremented the
   * RELAY_EARLY counter? This is for debugging task 878. */
  uint8_t relay_early_commands[MAX_RELAY_EARLY_CELLS_PER_CIRCUIT];

  /** How many RELAY_EARLY cells have been sent over this circuit? This is
   * for debugging task 878, too. */
  int relay_early_cells_sent;

  /** The next stream_id that will be tried when we&#39;re attempting to
   * construct a new AP stream originating at this circuit. */
  streamid_t next_stream_id;

  /** True if we have associated one stream to this circuit, thereby setting
   * the isolation parameters for this circuit.  Note that this doesn&#39;t
   * necessarily mean that we&#39;ve &lt;em&gt;attached&lt;/em&gt; any streams to the circuit:
   * we may only have marked up this circuit during the launch process.
   */
  unsigned int isolation_values_set : 1;
  /** True iff any stream has &lt;em&gt;ever&lt;/em&gt; been attached to this circuit.
   *
   * In a better world we could use timestamp_dirty for this, but
   * timestamp_dirty is far too overloaded at the moment.
   */
  unsigned int isolation_any_streams_attached : 1;

  /** A bitfield of ISO_* flags for every isolation field such that this
   * circuit has had streams with more than one value for that field
   * attached to it. */
  uint8_t isolation_flags_mixed;

  /** @name Isolation parameters
   *
   * If any streams have been associated with this circ (isolation_values_set
   * == 1), and all streams associated with the circuit have had the same
   * value for some field ((isolation_flags_mixed &amp; ISO_FOO) == 0), then these
   * elements hold the value for that field.
   *
   * Note again that &quot;associated&quot; is not the same as &quot;attached&quot;: we
   * preliminarily associate streams with a circuit while the circuit is being
   * launched, so that we can tell whether we need to launch more circuits.
   *
   * @{
   */
  uint8_t client_proto_type;
  uint8_t client_proto_socksver;
  uint16_t dest_port;
  tor_addr_t client_addr;
  char *dest_address;
  int session_group;
  unsigned nym_epoch;
  size_t socks_username_len;
  uint8_t socks_password_len;
  /* Note that the next two values are NOT NUL-terminated; see
     socks_username_len and socks_password_len for their lengths. */
  char *socks_username;
  char *socks_password;
  /** Global identifier for the first stream attached here; used by
   * ISO_STREAM. */
  uint64_t associated_isolated_stream_global_id;
  /**@}*/
  /** A list of addr_policy_t for this circuit in particular. Used by
   * adjust_exit_policy_from_exitpolicy_failure.
   */
  smartlist_t *prepend_policy;

  /** How long do we wait before closing this circuit if it remains
   * completely idle after it was built, in seconds? This value
   * is randomized on a per-circuit basis from CircuitsAvailableTimoeut
   * to 2*CircuitsAvailableTimoeut. */
  int circuit_idle_timeout;
</code></pre><h3 id="1-2-3-src-core-or-cpath_build_state_st-h">1.2.3 /src/core/or/cpath_build_state_st.h</h3>
<p>Information used to build a circuit.</p>
<pre><code>  /** Intended length of the final circuit. */
int desired_path_len;
  /** How to extend to the planned exit node. */
extend_info_t *chosen_exit;
  /** Whether every node in the circ must have adequate uptime. */
unsigned int need_uptime : 1;
  /** Whether every node in the circ must have adequate capacity. */
unsigned int need_capacity : 1;
  /** Whether the last hop was picked with exiting in mind. */
unsigned int is_internal : 1;
  /** Did we pick this as a one-hop tunnel (not safe for other streams)?
   * These are for encrypted dir conns that exit to this router, not
   * for arbitrary exits from the circuit. */
unsigned int onehop_tunnel : 1;
  /** The crypt_path_t to append after rendezvous: used for rendezvous. */
crypt_path_t *pending_final_cpath;
  /** A ref-counted reference to the crypt_path_t to append after
   * rendezvous; used on the service side. */
crypt_path_reference_t *service_pending_final_cpath_ref;
  /** How many times has building a circuit for this task failed? */
int failure_count;
  /** At what time should we give up on this task? */
time_t expiry_time;
</code></pre><h3 id="1-2-4-src-core-or-or_circuit_st-h">1.2.4 \src\core\or\or_circuit_st.h</h3>
<p>用于将两个connection链接在一起：edge connection和OR connection，或两个OR connection。（加入OR connection时，circuit_t仅影响发送到该connection上特定circID的cell。加入edge connection时，circuit_t影响所有数据）</p>
<h1 id="2-stream-circuit-">2 stream选择circuit算法</h1>
<p><img src="https://i.imgur.com/tF7ov5m.jpg" alt=""></p>
<h2 id="2-1-connection_ap_attach_pending-int-retry-">2.1 connection_ap_attach_pending(int retry)</h2>
<p>列出的所有等待新circuit重试的AP stream。 如果stream有可用circuit，请attach circuit。 否则，启动新circuit。 如果重试失败，则仅检查列表是否包含至少一个我们尚未尝试附加到circuit的stream。</p>
<h2 id="2-2-connection_ap_handshake_attach_circuit-entry_connection_t-conn-">2.2 connection_ap_handshake_attach_circuit(entry_connection_t *conn)</h2>
<p>Try to find a <strong>safe live</strong> circuit for stream conn.<br>If we find one,  attach the stream, send appropriate cells, and return 1.<br>Otherwise,  try to launch new circuit(s) for the stream.  If we can launch  circuits, return 0.<br>Otherwise, if we simply can’t proceed with  this stream, return -1.<br><img src="https://i.imgur.com/6rEX7JH.jpg" alt=""></p>
<h2 id="2-3-circuit_get_open_circ_or_launch-entry_connection_t-conn-uint8_t-desired_circuit_purpose-origin_circuit_t-circp-">2.3 circuit_get_open_circ_or_launch(entry_connection_t <em>conn,uint8_t desired_circuit_purpose,origin_circuit_t *</em>circp)</h2>
<p>Find an open circ that we’re <strong>happy</strong> to use for conn and return 1.(这个happy看的我一愣一愣的)<br>If there isn’t one, and there isn’t one on the way, launch one and return 0.<br>If it will never work, return -1.<br>Write the found(open) or in-progress(on the way) or launched circ into *circp.<br><img src="https://i.imgur.com/pEFDJI8.jpg" alt=""></p>
<h2 id="2-4-circuit_get_best-const-entry_connection_t-conn-int-must_be_open-uint8_t-purpose-int-need_uptime-int-need_internal-">2.4 circuit_get_best(const entry_connection_t *conn,int must_be_open, uint8_t purpose,int need_uptime, int need_internal)</h2>
<p>找到conn可以使用的最佳circuit，最好是脏的circuit。 circuit不能太老。<br>Conn必须被定义。<br>If must_be_open，请忽略不在CIRCUIT_STATE_OPEN中的circuit。<br>circ_purpose指定我们必须具有哪种circuit，它可以是C_GENERAL，C_INTRODUCE_ACK_WAIT或C_REND_JOINED。如果它是REND_JOINED且must_be_open == 0，则返回您可以找到的the closest rendezvous-purposed circuit。<br>如果它是INTRODUCE_ACK_WAIT并且must_be_open == 0，则返回您可以找到的最接近的引入专用circuit。<br><img src="https://i.imgur.com/5B1FLNN.jpg" alt=""></p>
<h2 id="2-5-circuit_is_acceptable-const-origin_circuit_t-origin_circ-const-entry_connection_t-conn-int-must_be_open-uint8_t-purpose-int-need_uptime-int-need_internal-time_t-now-">2.5 circuit_is_acceptable(const origin_circuit_t <em>origin_circ,const entry_connection_t </em>conn,int must_be_open, uint8_t purpose,int need_uptime, int need_internal,time_t now)</h2>
<p>去除那些不适合附加到stream的circuits，以便于circuit_is_better在剩下的circuits集合中选择一个最优的circuit。<br><img src="https://i.imgur.com/RMPfBny.jpg" alt=""></p>
<h2 id="2-6-circuit_is_better-const-origin_circuit_t-oa-const-origin_circuit_t-ob-const-entry_connection_t-conn-">2.6 circuit_is_better(const origin_circuit_t <em>oa, const origin_circuit_t </em>ob,const entry_connection_t *conn)</h2>
<p>暂且放一放</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
